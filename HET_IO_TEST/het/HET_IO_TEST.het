SCL_PIN      .equ    0                          ; HET00 is used for SCL
SDA_PIN      .equ    2                          ; HET02 is used for SDA


; i2cinit
; sda = 1
; scl = 1
; idle state, when i2c isn't doing anything
; we perform this when i2c_init.data is 0
; if data == 0 then execute i2c_init
; if data != 1 then skip to start

i2c_init   DJZ { next=i2c_start,cond_addr=i2c_init_01,irq=OFF,data=0};
i2c_init_01 ECMP { next=i2c_init_02,hr_lr=LOW,en_pin_action=ON,cond_addr=i2c_init_02,pin=SCL_PIN,action=SET,reg=A,irq=OFF,data=0};
i2c_init_02 ECMP { next=i2c_endlabel,hr_lr=LOW,en_pin_action=ON,cond_addr=i2c_endlabel,pin=SDA_PIN,action=CLEAR,reg=A,irq=OFF,data=0}; TODO this must be HIGH, I have set to LOW for testing

i2c_start br {next=i2c_init, cond_addr=i2c_init,event=nocond, irq=off} ; TODO this is placeholder needs implementation

i2c_repeat_start br {next=i2c_init, cond_addr=i2c_init,event=nocond, irq=off} ; TODO this is placeholder needs implementation

i2c_write br {next=i2c_init, cond_addr=i2c_init,event=nocond, irq=off} ; TODO this is placeholder needs implementation

i2c_read br {next=i2c_init, cond_addr=i2c_init,event=nocond, irq=off} ; TODO this is placeholder needs implementation

i2c_ack br {next=i2c_init, cond_addr=i2c_init,event=nocond, irq=off} ; TODO this is placeholder needs implementation

i2c_stop br {next=i2c_init, cond_addr=i2c_init,event=nocond, irq=off} ; TODO this is placeholder needs implementation

i2c_endlabel br {next=i2c_init, cond_addr=i2c_init,event=nocond, irq=off}

